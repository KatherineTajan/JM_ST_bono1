Traceback (most recent call last):
  File "/opt/miniconda3/envs/ml_venv/lib/python3.12/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/opt/miniconda3/envs/ml_venv/lib/python3.12/site-packages/nbclient/client.py", line 1314, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/opt/miniconda3/envs/ml_venv/lib/python3.12/site-packages/jupyter_core/utils/__init__.py", line 165, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/opt/miniconda3/envs/ml_venv/lib/python3.12/asyncio/base_events.py", line 685, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "/opt/miniconda3/envs/ml_venv/lib/python3.12/site-packages/nbclient/client.py", line 709, in async_execute
    await self.async_execute_cell(
  File "/opt/miniconda3/envs/ml_venv/lib/python3.12/site-packages/nbclient/client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/opt/miniconda3/envs/ml_venv/lib/python3.12/site-packages/nbclient/client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Funci√≥n de suavizaci√≥n exponencial simple
def firstsmooth(y, lambda_, start=None):
    ytilde = y.copy()
    if start is None:
        start = y[0]
    ytilde[0] = lambda_ * y[0] + (1 - lambda_) * start
    for i in range(1, len(y)):
        ytilde[i] = lambda_ * y[i] + (1 - lambda_) * ytilde[i - 1]
    return ytilde

# Funci√≥n de m√©tricas de precisi√≥n
def measacc_fs(y_true, y_pred):
    T = len(y_true)
    prederr = y_true - y_pred
    SSE = sum(prederr**2)
    MAPE = 100 * sum(abs(prederr / y_true)) / T
    MAD = sum(abs(prederr)) / T
    MSD = sum(prederr**2) / T
    return {"SSE": SSE, "MAPE": MAPE, "MAD": MAD, "MSD": MSD}

# Funci√≥n para calcular solo MAE (MAD)
def calculate_mae(y_true, y_pred):
    MAE = sum(abs(y_true - y_pred)) / len(y_true)
    return MAE

# Par√°metro lambda (tasa de suavizaci√≥n)
lambda_ = 0.4

# Lista de DataFrames y nombres para iterar
dataframes = [df_ex_1, df_ex_9, df_ex_20, df_ex_21, df_ex_23, df_ex_24]
names = ['ex_1', 'ex_9', 'ex_20', 'ex_21', 'ex_23', 'ex_24']

# Divisi√≥n en entrenamiento, validaci√≥n y test
train_size = 0.8  # 80% para entrenamiento
val_size = 0.1    # 10% para validaci√≥n
test_size = 0.1   # 10% para test

# Crear un DataFrame para almacenar todas las m√©tricas
metrics_df = pd.DataFrame(columns=['Experimento', 'SSE_Train', 'MAPE_Train', 'MAD_Train', 'MSD_Train',
                                   'SSE_Val', 'MAPE_Val', 'MAD_Val', 'MSD_Val', 'MAE_Test'])

# Aplicar suavizaci√≥n exponencial simple manual a cada serie de tiempo
for df, name in zip(dataframes, names):
    # Definir la longitud de cada conjunto
    n = len(df)
    train_end = int(train_size * n)
    val_end = train_end + int(val_size * n)
    
    # Dividir en conjuntos de entrenamiento, validaci√≥n y test
    train_data = df['el_power'][:train_end]
    val_data = df['el_power'][train_end:val_end]
    test_data = df['el_power'][val_end:]
    
    # Aplicar la suavizaci√≥n en los datos de entrenamiento + validaci√≥n
    smooth_train_val = firstsmooth(np.concatenate([train_data.values, val_data.values]), lambda_)
    
    # Extraer las partes suavizadas para entrenamiento y validaci√≥n
    smooth_train = smooth_train_val[:train_end]  # Suavizaci√≥n para el entrenamiento
    smooth_val = smooth_train_val[train_end:val_end]  # Suavizaci√≥n para la validaci√≥n
    
    # Predicci√≥n para el conjunto de test usando el √∫ltimo valor del conjunto de validaci√≥n
    smooth_test = np.full(len(test_data), smooth_val[-1])
    
    # Graficar la serie original con tres colores para los conjuntos de datos
    plt.figure(figsize=(10, 6))
    plt.plot(df['time'][:train_end], df['el_power'][:train_end], color='blue', label='Entrenamiento')
    plt.plot(df['time'][train_end:val_end], df['el_power'][train_end:val_end], color='orange', label='Validaci√≥n')
    plt.plot(df['time'][val_end:], df['el_power'][val_end:], color='green', label='Test')
    
    # Graficar la suavizaci√≥n en entrenamiento y validaci√≥n
    plt.plot(df['time'][:train_end], smooth_train, color='red', linestyle='--', label=f'Suavizaci√≥n SES Entrenamiento ($\lambda={lambda_}$)')
    plt.plot(df['time'][train_end:val_end], smooth_val, color='red', linestyle='--')
    plt.plot(df['time'][val_end:], smooth_test, color='red', linestyle='--', label='Predicci√≥n Test')
    
    # Configuraci√≥n del gr√°fico
    plt.title(f'SES con Entrenamiento, Validaci√≥n y Predicci√≥n en Test - {name}')
    plt.xlabel('Tiempo')
    plt.ylabel('Potencia El√©ctrica (W)')
    plt.legend()
    plt.show()

    # Calcular las m√©tricas de precisi√≥n en el conjunto de entrenamiento
    metrics_train = measacc_fs(train_data.values, smooth_train)
    
    # Calcular las m√©tricas de precisi√≥n en el conjunto de validaci√≥n
    metrics_val = measacc_fs(val_data.values, smooth_val)
    
    # Calcular solo el MAE (MAD) en el conjunto de test
    mae_test = calculate_mae(test_data.values, smooth_test)
    
    # Crear un DataFrame temporal con las m√©tricas del experimento actual
    temp_df = pd.DataFrame({
        'Experimento': [name],
        'SSE_Train': [metrics_train['SSE']], 'MAPE_Train': [metrics_train['MAPE']],
        'MAD_Train': [metrics_train['MAD']], 'MSD_Train': [metrics_train['MSD']],
        'SSE_Val': [metrics_val['SSE']], 'MAPE_Val': [metrics_val['MAPE']],
        'MAD_Val': [metrics_val['MAD']], 'MSD_Val': [metrics_val['MSD']],
        'MAE_Test': [mae_test]
    })
    
    # Usar pd.concat() para agregar las filas al DataFrame de m√©tricas
    metrics_df = pd.concat([metrics_df, temp_df], ignore_index=True)



------------------

----- stderr -----
<>:75: SyntaxWarning: invalid escape sequence '\l'
<>:75: SyntaxWarning: invalid escape sequence '\l'
/var/folders/pc/g1c35bc91zbfqvk3gwrrc_5c0000gn/T/ipykernel_45284/2071969763.py:75: SyntaxWarning: invalid escape sequence '\l'
  plt.plot(df['time'][:train_end], smooth_train, color='red', linestyle='--', label=f'Suavizaci√≥n SES Entrenamiento ($\lambda={lambda_}$)')
----- stderr -----
/var/folders/pc/g1c35bc91zbfqvk3gwrrc_5c0000gn/T/ipykernel_45284/2071969763.py:75: SyntaxWarning: invalid escape sequence '\l'
  plt.plot(df['time'][:train_end], smooth_train, color='red', linestyle='--', label=f'Suavizaci√≥n SES Entrenamiento ($\lambda={lambda_}$)')
------------------

[0;31m---------------------------------------------------------------------------[0m
[0;31mNameError[0m                                 Traceback (most recent call last)
Cell [0;32mIn[2], line 34[0m
[1;32m     31[0m lambda_ [38;5;241m=[39m [38;5;241m0.4[39m
[1;32m     33[0m [38;5;66;03m# Lista de DataFrames y nombres para iterar[39;00m
[0;32m---> 34[0m dataframes [38;5;241m=[39m [[43mdf_ex_1[49m, df_ex_9, df_ex_20, df_ex_21, df_ex_23, df_ex_24]
[1;32m     35[0m names [38;5;241m=[39m [[38;5;124m'[39m[38;5;124mex_1[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mex_9[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mex_20[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mex_21[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mex_23[39m[38;5;124m'[39m, [38;5;124m'[39m[38;5;124mex_24[39m[38;5;124m'[39m]
[1;32m     37[0m [38;5;66;03m# Divisi√≥n en entrenamiento, validaci√≥n y test[39;00m

[0;31mNameError[0m: name 'df_ex_1' is not defined

